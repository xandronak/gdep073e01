<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Extension trait for `DrawTarget`s."><title>DrawTargetExt in gdep073e01::prelude - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Italic-81dc35de.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-MediumItalic-ccf7e434.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../../static.files/rustdoc-1a91846b.css"><meta name="rustdoc-vars" data-root-path="../../" data-static-root-path="../../static.files/" data-current-crate="gdep073e01" data-themes="" data-resource-suffix="" data-rustdoc-version="1.88.0 (6b00bc388 2025-06-23)" data-channel="1.88.0" data-search-js="search-f7877310.js" data-settings-js="settings-5514c975.js" ><script src="../../static.files/storage-4e99c027.js"></script><script defer src="sidebar-items.js"></script><script defer src="../../static.files/main-7ef8a74a.js"></script><noscript><link rel="stylesheet" href="../../static.files/noscript-893ab5e7.css"></noscript><link rel="alternate icon" type="image/png" href="../../static.files/favicon-32x32-6580c154.png"><link rel="icon" type="image/svg+xml" href="../../static.files/favicon-044be391.svg"></head><body class="rustdoc trait"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../../gdep073e01/index.html">gdep073e01</a><span class="version">0.3.0</span></h2></div><div class="sidebar-elems"><section id="rustdoc-toc"><h2 class="location"><a href="#">Draw<wbr>Target<wbr>Ext</a></h2><h3><a href="#required-methods">Required Methods</a></h3><ul class="block"><li><a href="#tymethod.clipped" title="clipped">clipped</a></li><li><a href="#tymethod.color_converted" title="color_converted">color_converted</a></li><li><a href="#tymethod.cropped" title="cropped">cropped</a></li><li><a href="#tymethod.translated" title="translated">translated</a></li></ul><h3><a href="#dyn-compatibility">Dyn Compatibility</a></h3><h3><a href="#implementors">Implementors</a></h3></section><div id="rustdoc-modnav"><h2><a href="index.html">In gdep073e01::<wbr>prelude</a></h2></div></div></nav><div class="sidebar-resizer"></div><main><div class="width-limiter"><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><div class="rustdoc-breadcrumbs"><a href="../index.html">gdep073e01</a>::<wbr><a href="index.html">prelude</a></div><h1>Trait <span class="trait">DrawTargetExt</span><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"></span></div><pre class="rust item-decl"><code>pub trait DrawTargetExt: <a class="trait" href="https://doc.rust-lang.org/1.88.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a> + <a class="trait" href="trait.DrawTarget.html" title="trait gdep073e01::prelude::DrawTarget">DrawTarget</a> {
    // Required methods
    fn <a href="#tymethod.translated" class="fn">translated</a>(&amp;mut self, offset: <a class="struct" href="struct.Point.html" title="struct gdep073e01::prelude::Point">Point</a>) -&gt; Translated&lt;'_, Self&gt;;
<span class="item-spacer"></span>    fn <a href="#tymethod.cropped" class="fn">cropped</a>(&amp;mut self, area: &amp;Rectangle) -&gt; Cropped&lt;'_, Self&gt;;
<span class="item-spacer"></span>    fn <a href="#tymethod.clipped" class="fn">clipped</a>(&amp;mut self, area: &amp;Rectangle) -&gt; Clipped&lt;'_, Self&gt;;
<span class="item-spacer"></span>    fn <a href="#tymethod.color_converted" class="fn">color_converted</a>&lt;C&gt;(&amp;mut self) -&gt; ColorConverted&lt;'_, Self, C&gt;
       <span class="where">where C: <a class="trait" href="trait.PixelColor.html" title="trait gdep073e01::prelude::PixelColor">PixelColor</a> + <a class="trait" href="https://doc.rust-lang.org/1.88.0/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;Self::<a class="associatedtype" href="trait.DrawTarget.html#associatedtype.Color" title="type gdep073e01::prelude::DrawTarget::Color">Color</a>&gt;</span>;
}</code></pre><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>Extension trait for <code>DrawTarget</code>s.</p>
</div></details><h2 id="required-methods" class="section-header">Required Methods<a href="#required-methods" class="anchor">§</a></h2><div class="methods"><details class="toggle method-toggle" open><summary><section id="tymethod.translated" class="method"><h4 class="code-header">fn <a href="#tymethod.translated" class="fn">translated</a>(&amp;mut self, offset: <a class="struct" href="struct.Point.html" title="struct gdep073e01::prelude::Point">Point</a>) -&gt; Translated&lt;'_, Self&gt;</h4></section></summary><div class="docblock"><p>Creates a translated draw target based on this draw target.</p>
<p>All drawing operations are translated by <code>offset</code> pixels, before being passed to the parent
draw target.</p>
<h5 id="examples"><a class="doc-anchor" href="#examples">§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>embedded_graphics::{
    mock_display::MockDisplay,
    mono_font::{ascii::FONT_6X9, MonoTextStyle},
    pixelcolor::BinaryColor,
    prelude::<span class="kw-2">*</span>,
    text::Text,
};

<span class="kw">let </span><span class="kw-2">mut </span>display = MockDisplay::new();
<span class="kw">let </span><span class="kw-2">mut </span>translated_display = display.translated(Point::new(<span class="number">5</span>, <span class="number">10</span>));

<span class="kw">let </span>style = MonoTextStyle::new(<span class="kw-2">&amp;</span>FONT_6X9, BinaryColor::On);

<span class="comment">// Draws text at position (5, 10) in the display coordinate system
</span>Text::new(<span class="string">"Text"</span>, Point::zero(), style).draw(<span class="kw-2">&amp;mut </span>translated_display)<span class="question-mark">?</span>;</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="tymethod.cropped" class="method"><h4 class="code-header">fn <a href="#tymethod.cropped" class="fn">cropped</a>(&amp;mut self, area: &amp;Rectangle) -&gt; Cropped&lt;'_, Self&gt;</h4></section></summary><div class="docblock"><p>Creates a cropped draw target based on this draw target.</p>
<p>A cropped draw target is a draw target for a rectangular subregion of the parent draw target.
Its coordinate system is shifted so that the origin coincides with <code>area.top_left</code> in the
parent draw target’s coordinate system.</p>
<p>The bounding box of the returned target will always be contained inside the bounding box
of the parent target. If any of the requested <code>area</code> lies outside the parent target’s bounding
box the intersection of the parent target’s bounding box and <code>area</code> will be used.</p>
<p>Drawing operations outside the bounding box will not be clipped.</p>
<h5 id="examples-1"><a class="doc-anchor" href="#examples-1">§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>embedded_graphics::{
    mock_display::MockDisplay,
    mono_font::{ascii::FONT_6X9, MonoTextStyle},
    pixelcolor::Rgb565,
    prelude::<span class="kw-2">*</span>,
    primitives::Rectangle,
    text::{Text, Alignment, Baseline, TextStyleBuilder},
};

<span class="doccomment">/// Fills a draw target with a blue background and prints centered yellow text.
</span><span class="kw">fn </span>draw_text&lt;T&gt;(target: <span class="kw-2">&amp;mut </span>T, text: <span class="kw-2">&amp;</span>str) -&gt; <span class="prelude-ty">Result</span>&lt;(), T::Error&gt;
<span class="kw">where
    </span>T: DrawTarget&lt;Color = Rgb565&gt;,
{
    target.clear(Rgb565::BLUE)<span class="question-mark">?</span>;

    <span class="kw">let </span>text_position = target.bounding_box().center();

    <span class="kw">let </span>character_style = MonoTextStyle::new(<span class="kw-2">&amp;</span>FONT_6X9, Rgb565::YELLOW);
    <span class="kw">let </span>text_style = TextStyleBuilder::new()
        .alignment(Alignment::Center)
        .baseline(Baseline::Middle)
        .build();

    Text::with_text_style(text, text_position, character_style, text_style).draw(target)<span class="question-mark">?</span>;

    <span class="prelude-val">Ok</span>(())
}

<span class="kw">let </span><span class="kw-2">mut </span>display = MockDisplay::new();
display.set_allow_overdraw(<span class="bool-val">true</span>);

<span class="kw">let </span>area = Rectangle::new(Point::new(<span class="number">5</span>, <span class="number">10</span>), Size::new(<span class="number">40</span>, <span class="number">15</span>));
<span class="kw">let </span><span class="kw-2">mut </span>cropped_display = display.cropped(<span class="kw-2">&amp;</span>area);

draw_text(<span class="kw-2">&amp;mut </span>cropped_display, <span class="string">"Text"</span>)<span class="question-mark">?</span>;</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="tymethod.clipped" class="method"><h4 class="code-header">fn <a href="#tymethod.clipped" class="fn">clipped</a>(&amp;mut self, area: &amp;Rectangle) -&gt; Clipped&lt;'_, Self&gt;</h4></section></summary><div class="docblock"><p>Creates a clipped draw target based on this draw target.</p>
<p>A clipped draw target is a draw target for a rectangular subregion of the parent draw target.
The coordinate system of the created draw target is equal to the parent target’s coordinate
system. All drawing operations outside the bounding box will be clipped.</p>
<p>The bounding box of the returned target will always be contained inside the bounding box
of the parent target. If any of the requested <code>area</code> lies outside the parent target’s bounding
box the intersection of the parent target’s bounding box and <code>area</code> will be used.</p>
<h5 id="examples-2"><a class="doc-anchor" href="#examples-2">§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>embedded_graphics::{
    mock_display::MockDisplay,
    mono_font::{ascii::FONT_10X20, MonoTextStyle},
    pixelcolor::BinaryColor,
    prelude::<span class="kw-2">*</span>,
    primitives::Rectangle,
    text::Text,
};

<span class="kw">let </span><span class="kw-2">mut </span>display = MockDisplay::new();

<span class="kw">let </span>area = Rectangle::new(Point::zero(), Size::new(<span class="number">4 </span>* <span class="number">10</span>, <span class="number">20</span>));
<span class="kw">let </span><span class="kw-2">mut </span>clipped_display = display.clipped(<span class="kw-2">&amp;</span>area);

<span class="kw">let </span>style = MonoTextStyle::new(<span class="kw-2">&amp;</span>FONT_10X20, BinaryColor::On);

<span class="comment">// Only the first 4 characters will be drawn, because the others are outside
// the clipping area
</span>Text::new(<span class="string">"Clipped"</span>, Point::new(<span class="number">0</span>, <span class="number">15</span>), style).draw(<span class="kw-2">&amp;mut </span>clipped_display)<span class="question-mark">?</span>;</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="tymethod.color_converted" class="method"><h4 class="code-header">fn <a href="#tymethod.color_converted" class="fn">color_converted</a>&lt;C&gt;(&amp;mut self) -&gt; ColorConverted&lt;'_, Self, C&gt;<div class="where">where
    C: <a class="trait" href="trait.PixelColor.html" title="trait gdep073e01::prelude::PixelColor">PixelColor</a> + <a class="trait" href="https://doc.rust-lang.org/1.88.0/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;Self::<a class="associatedtype" href="trait.DrawTarget.html#associatedtype.Color" title="type gdep073e01::prelude::DrawTarget::Color">Color</a>&gt;,</div></h4></section></summary><div class="docblock"><p>Creates a color conversion draw target.</p>
<p>A color conversion draw target is used to draw drawables with a different color type to a
draw target. The drawable color type must implement <code>Into&lt;C&gt;</code>, where <code>C</code> is the draw
target color type.</p>
<h5 id="performance"><a class="doc-anchor" href="#performance">§</a>Performance</h5>
<p>Color conversion can be expensive on embedded hardware and should be avoided if possible.
Using the same color type for drawables and the draw target makes sure that no unnecessary
color conversion is used. But in some cases color conversion will be required, for example,
to draw images with a color format only known at runtime.</p>
<h5 id="examples-3"><a class="doc-anchor" href="#examples-3">§</a>Examples</h5>
<p>This example draws a <code>BinaryColor</code> image to an <code>Rgb888</code> display.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>embedded_graphics::{
    image::{Image, ImageRaw},
    mock_display::MockDisplay,
    pixelcolor::{BinaryColor, Rgb888},
    prelude::<span class="kw-2">*</span>,
};

<span class="doccomment">/// The image data.
</span><span class="kw">const </span>DATA: <span class="kw-2">&amp;</span>[u8] = <span class="kw-2">&amp;</span>[
    <span class="number">0b11110000</span>, <span class="comment">//
    </span><span class="number">0b10010000</span>, <span class="comment">//
    </span><span class="number">0b10010000</span>, <span class="comment">//
    </span><span class="number">0b11110000</span>, <span class="comment">//
</span>];

<span class="comment">// Create a `BinaryColor` image from the image data.
</span><span class="kw">let </span>raw_image = ImageRaw::&lt;BinaryColor&gt;::new(DATA, <span class="number">4</span>);
<span class="kw">let </span>image = Image::new(<span class="kw-2">&amp;</span>raw_image, Point::zero());

<span class="comment">// Create a `Rgb888` display.
</span><span class="kw">let </span><span class="kw-2">mut </span>display = MockDisplay::&lt;Rgb888&gt;::new();

<span class="comment">// The image can't directly be drawn to the draw target because they use different
// color type. This will fail to compile:
// image.draw(&amp;mut display)?;

// To fix this `color_converted` is added to enable color conversion.
</span>image.draw(<span class="kw-2">&amp;mut </span>display.color_converted())<span class="question-mark">?</span>;</code></pre></div>
</div></details></div><h2 id="dyn-compatibility" class="section-header">Dyn Compatibility<a href="#dyn-compatibility" class="anchor">§</a></h2><div class="dyn-compatibility-info"><p>This trait is <b>not</b> <a href="https://doc.rust-lang.org/1.88.0/reference/items/traits.html#dyn-compatibility">dyn compatible</a>.</p><p><i>In older versions of Rust, dyn compatibility was called "object safety", so this trait is not object safe.</i></p></div><h2 id="implementors" class="section-header">Implementors<a href="#implementors" class="anchor">§</a></h2><div id="implementors-list"><section id="impl-DrawTargetExt-for-T" class="impl"><a href="#impl-DrawTargetExt-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="trait.DrawTargetExt.html" title="trait gdep073e01::prelude::DrawTargetExt">DrawTargetExt</a> for T<div class="where">where
    T: <a class="trait" href="trait.DrawTarget.html" title="trait gdep073e01::prelude::DrawTarget">DrawTarget</a>,</div></h3></section></div><script src="../../trait.impl/embedded_graphics/draw_target/trait.DrawTargetExt.js" async></script></section></div></main></body></html>